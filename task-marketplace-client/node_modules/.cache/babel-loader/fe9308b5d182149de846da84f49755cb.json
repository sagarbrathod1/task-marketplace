{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nvar initialState = {\n  authorized: false,\n  token: \"\"\n}; // The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\n\n/*export const incrementAsync = createAsyncThunk(\n  'counter/fetchCount',\n  async (amount) => {\n    const response = await fetchCount(amount);\n    // The value we return becomes the `fulfilled` action payload\n    return response.data;\n  }\n);*/\n\nexport var auth_slice = createSlice({\n  name: 'auth',\n  initialState: initialState,\n  reducers: {\n    set_authorized: function set_authorized(state, token) {\n      state.authorized = true;\n      state.token = token.payload;\n    },\n    set_unauthorized: function set_unauthorized(state) {\n      state.authorized = false;\n    }\n  } // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n\n  /* extraReducers: (builder) => {\n     builder\n       .addCase(incrementAsync.pending, (state) => {\n         state.status = 'loading';\n       })\n       .addCase(incrementAsync.fulfilled, (state, action) => {\n         state.status = 'idle';\n         state.value += action.payload;\n       });\n   },*/\n\n});\nvar _auth_slice$actions = auth_slice.actions,\n    set_authorized = _auth_slice$actions.set_authorized,\n    set_unauthorized = _auth_slice$actions.set_unauthorized;\nexport { set_authorized, set_unauthorized };\nexport var select_authorized = function select_authorized(state) {\n  return state.auth.authorized;\n}; // We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\n\n/*export const incrementIfOdd = (amount) => (dispatch, getState) => {\n  const currentValue = selectCount(getState());\n  if (currentValue % 2 === 1) {\n    dispatch(incrementByAmount(amount));\n  }\n};*/\n\nexport default auth_slice.reducer;","map":{"version":3,"names":["createAsyncThunk","createSlice","initialState","authorized","token","auth_slice","name","reducers","set_authorized","state","payload","set_unauthorized","actions","select_authorized","auth","reducer"],"sources":["/Users/sagarrathod/Desktop/Project 2/task-marketplace-client/src/features/auth/auth-slice.js"],"sourcesContent":["import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\n\nconst initialState = {\n  authorized: false,\n  token: \"\"\n};\n\n// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\n/*export const incrementAsync = createAsyncThunk(\n  'counter/fetchCount',\n  async (amount) => {\n    const response = await fetchCount(amount);\n    // The value we return becomes the `fulfilled` action payload\n    return response.data;\n  }\n);*/\n\nexport const auth_slice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    set_authorized: (state, token) => {\n      state.authorized = true;\n      state.token = token.payload;\n    },\n    set_unauthorized: (state) => {\n      state.authorized = false;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n /* extraReducers: (builder) => {\n    builder\n      .addCase(incrementAsync.pending, (state) => {\n        state.status = 'loading';\n      })\n      .addCase(incrementAsync.fulfilled, (state, action) => {\n        state.status = 'idle';\n        state.value += action.payload;\n      });\n  },*/\n});\n\nexport const { set_authorized, set_unauthorized} = auth_slice.actions;\n\nexport const select_authorized = (state) => state.auth.authorized;\n\n// We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\n/*export const incrementIfOdd = (amount) => (dispatch, getState) => {\n  const currentValue = selectCount(getState());\n  if (currentValue % 2 === 1) {\n    dispatch(incrementByAmount(amount));\n  }\n};*/\n\nexport default auth_slice.reducer;\n"],"mappings":"AAAA,SAASA,gBAAT,EAA2BC,WAA3B,QAA8C,kBAA9C;AAEA,IAAMC,YAAY,GAAG;EACnBC,UAAU,EAAE,KADO;EAEnBC,KAAK,EAAE;AAFY,CAArB,C,CAKA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAMC,UAAU,GAAGJ,WAAW,CAAC;EACpCK,IAAI,EAAE,MAD8B;EAEpCJ,YAAY,EAAZA,YAFoC;EAGpCK,QAAQ,EAAE;IACRC,cAAc,EAAE,wBAACC,KAAD,EAAQL,KAAR,EAAkB;MAChCK,KAAK,CAACN,UAAN,GAAmB,IAAnB;MACAM,KAAK,CAACL,KAAN,GAAcA,KAAK,CAACM,OAApB;IACD,CAJO;IAKRC,gBAAgB,EAAE,0BAACF,KAAD,EAAW;MAC3BA,KAAK,CAACN,UAAN,GAAmB,KAAnB;IACD;EAPO,CAH0B,CAYpC;EACA;;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAvBsC,CAAD,CAA9B;0BA0B4CE,UAAU,CAACO,O;IAA/CJ,c,uBAAAA,c;IAAgBG,gB,uBAAAA,gB;;AAE/B,OAAO,IAAME,iBAAiB,GAAG,SAApBA,iBAAoB,CAACJ,KAAD;EAAA,OAAWA,KAAK,CAACK,IAAN,CAAWX,UAAtB;AAAA,CAA1B,C,CAEP;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAeE,UAAU,CAACU,OAA1B"},"metadata":{},"sourceType":"module"}